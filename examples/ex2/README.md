# Canvas Example

This example is based off of the "Custom Drawing" example from the *GTK+ 3 Reference Manual*. This demonstrates the same concept of using a `GtkDrawingArea` as a canvas. The `GtkCanvas` widget provided by the Gtk wrapper library would ordinarily be used to implement this but there is no means to create a `GtkCanvas` widget in the UI files as that widget is not actually a `GObject` but is instead a bit of functionality built around the `GtkDrawingArea` widget.

## UI File

The UI file consists only of a `GtkWindow` containing a `GtkDrawingArea`.

### `GtkApplicationWindow` widget

Nothing needs to be manipulated on the `GtkApplicationWindow` widget.

### `GtkDrawingArea` widget

The `GtkDrawingArea` widget must be configured significantly before being used. First, the Pointer Motion, Button Press, and Structure events must be selected under the Common tab. Note that for purposes of basic drawing only the Structure event, which is required for the `configure-event` signal, is necessary while the other events are just for handling mouse events. Second, at the bottom of the Common tab, the width and height requests must be explicitly set to indicate the size in pixels for our canvas. Third, the `button-press-event`, `configure-event`, `draw`, and `motion-notify-event` must all be connected to their handlers.

## Julia File

### `clear_surface` function 

This function paints the entirety of a `CairoSurface` white.

```julia
function clear_surface(surf::CairoSurface)
  ctx = CairoContext(surf)
  set_source_rgb(ctx, 1, 1, 1)
  paint(ctx)
end
```

### `draw_brush`

This function paints a particular part of the `CairoSurface` black then forces part of the widget to update using `reveal_area`.

```julia
function draw_brush(
    canvas,
    x,
    y,
    surf)
  px = Int(round(x - 3))
  py = Int(round(y - 3))
  ctx = CairoContext(surf)
  rectangle(ctx, px, py, 6, 6)
  fill(ctx)
  reveal_area(canvas, px, py, 6, 6)
end
```

### `configure_event_cb`

This handler is triggered whenever the size, position, or stacking of the widget has changed. When this handler is called it creates a new Cairo surface based on the widget's new dimensions and clears that new surface to white.

```julia
@guarded Cint(0) function configure_event_cb(
    canvas,
    configure_event,
    userdata)
  userdata.surface = create_similar_surface(canvas, Gtk.GEnum(Cairo.CONTENT_COLOR_ALPHA))
  clear_surface(userdata.surface)
  return Cint(1)
end
```

### `draw_cb`

This handler is called whenever the widget needs to be drawn. The screen is redrawn by using a `CairoContext` provided by the signal and painting it with the contents of the `CairoSurface` that we've been holding onto.

```julia
@guarded Cint(1) function draw_cb(
    canvas,
    ctx_ptr,
    userdata)

  ctx = CairoContext(ctx_ptr)

  set_source_surface(ctx, userdata.surface, 0, 0)
  paint(ctx)
  return Cint(0)
end
```

### `button_press_event_cb`

This handler is triggered whenever the mouse pointer is pressed down while above the `GtkDrawingArea` widget. If the left mouse button is clicked, a dot is drawn on the canvas under the pointer. If the right mouse button is clicked the canvas is reset to white and the widget is forced to update to reflect this change.

```julia
@guarded Cint(0) function button_press_event_cb(
    canvas,
    event_ptr,
    userdata) 

  event = Gtk.GdkEvent(event_ptr)

  # Make sure the surface is valid
  if userdata.surface.ptr == C_NULL
    return Cint(0)
  end

  if event.button == 1
    draw_brush(canvas, event.x, event.y, userdata.surface)
  elseif event.button == 3
    clear_surface(userdata.surface)
    reveal(canvas, false)
  end

  return Cint(1)
end
```

### `motion_notify_event_cb`

This handler is triggered whenever the mouse pointer moves while above the `GtkDrawingArea` widget. If the left mouse button is being held down a dot is drawn below the pointer on the canvas, otherwise nothing happens.

```julia
@guarded Cint(0) function motion_notify_event_cb(
    canvas,
    event_ptr,
    userdata)

  event = Gtk.GdkEvent(event_ptr)

  # Make sure the surface is valid
  if userdata.surface.ptr == C_NULL
    return Cint(0)
  end

  if (event.state & Gtk.GdkModifierType.BUTTON1) != 0
    draw_brush(canvas, event.x, event.y, userdata.surface)
  end

  return Cint(1)

end
```

### `activate_cb`

This is still a handler but is not referenced in the Glade UI file so it is left outside that block and will be connected in code instead. This handler is triggered during the start-up of the application. The `canvas_builder` function, which was generated by the macro above, is used to create the `GtkBuilder` object from the UI file and connects the handlers described above to their signals. The main application window is then added onto the `GtkApplication` that is started so that when that window closes the application will also close. Finally, the window is shown causing its contents to be rendered.

```julia
@guarded function activate_cb(
    app_ptr,
    userdata)
  app = GObject(app_ptr)
  # Start with an under-defined cairo surface
  built = canvas_builder(
    "resources/main.ui", 
    CanvasData(CairoSurface(C_NULL, -1, -1)))

  w = Gtk.GAccessor.object(built, "drawing_window")

  push!(app, w)
  showall(w)

  return nothing
end
```

### Start-Up

The `GtkApplication` is created with the identity `io.github.matt5sean3.second` and has `activate_cb` connected to its `activate` signal. This application is then run.

```julia
app = GtkApplication("io.github.matt5sean3.GtkBuilderAid.second", 0)
signal_connect(activate_cb, app, "activate", Void, (), false)
println("Start application")
run(app)
```

## A note on memory management

If you're familiar with these libraries from C you may have noticed that there are no explicit calls to `cairo_surface_destroy` or `cairo_destroy`. These are unnecessary as the Julia objects `CairoSurface` and `CairoContext` call these internally when they're garbage collected.

